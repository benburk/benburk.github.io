<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">

      <title>
  Mira | Ben Burk
</title>

      <link rel="stylesheet" href="https://benburk.github.io/henry.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,700|Roboto+Slab|Source+Code+Pro">

      

      
      
    </head>

    <body>
        <header>
            <div class="header-content">
                <a class="header-content-title" href="https:&#x2F;&#x2F;benburk.github.io">Ben Burk</a>
                <nav class="header-content-nav">
                    <a href="#" class="header-content-nav-icon">
                    <svg viewBox="0 0 18 15" width="18">
                        <path fill="#5c5c5c" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                        <path fill="#5c5c5c" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                        <path fill="#5c5c5c" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                    </svg>
                    </a>
                    <div class="header-content-nav-trigger">
                        
                        
                        <a class="header-content-nav-trigger-link" href="&#x2F;about">About</a>
                        
                        
                    </div>
                </nav>
            </div>
        </header>

        <main class="blog">
            
<main class="page">
    <article class="page-content" itemscope itemtype="http://schema.org/BlogPosting">
        <h1 class="page-content-title" itemprop="name headline">Mira</h1>
        <div class="page-content-meta">
            <time datetime="2022-05-27T00:00:00+00:00" itemprop="datePublished">May 27, 2022</time>
        </div>
        <div class="page-content-body" itemprop="articleBody">
            <p>Mira is an 8-bit CPU architecture designed to have an efficient implementation in Minecraft completed in September 2021.</p>
<h1 id="instruction-set">Instruction set</h1>
<p>The instruction set architecture (ISA) for the CPU takes inspiration from the 6502 and 8008 microprocessors. The CPU is accumulator-based and could be classified as CISC with its variable length instructions and ability to use memory directly as an argument. The feature-rich and orthogonal ISA makes it a joy to write programs for. It features:</p>
<ul>
<li>16 instructions</li>
<li>Five registers: an accumulator (A) and four general-purpose registers (B, C, X, Y)</li>
<li>Four condition flags: carry, zero, overflow, and sign</li>
<li>Five addressing modes: immediate, memory, indexed-memory, registers, and accumulator</li>
<li>8-bit variable-length instructions (taking 1-3 bytes)</li>
<li>8-bit address space (can use Harvard or Von-Neumann layout, and <a href="https://en.wikipedia.org/wiki/Bank_switching">bank switching</a> to increase it)</li>
<li>Memory-mapped I/O</li>
</ul>
<!-- ![ISA](./content/images/mira-isa.png) -->
<p><img src="/images/mira-isa.png" alt="ISA" /></p>
<p>This is the canonical bit-encoding for the ISA. An implementation is free to shift instructions and bits around to decode it more efficiently, as was done for Minecraft. An implementation is considered valid as long as any assembly program can be executed on it.</p>
<h3 id="flags">Flags</h3>
<p>On the left, we have the four processor flags. The presence of a letter in a column indicates whether the instruction updates this flag. The flags can not be written to or read from directly. They are modified as a side effect of other instructions, or read when performing conditional branching.</p>
<ul>
<li><code>Negative</code>: Set if bit 7 of the result is set</li>
<li><code>Zero</code>: Set if the result was zero</li>
<li><code>Carry</code>: Set if the arithmetic operation produced a carry or borrow. It also holds bits after a shift.</li>
<li><code>oVerflow</code>: Set if the addition of two like-signed numbers or the subtraction of two unlike-signed numbers produces a result greater than +127 or less than -128.</li>
</ul>
<h3 id="addressing-modes">Addressing modes</h3>
<p>Shifting our attention to the top-right, we have the addressing modes. All instructions with an <code>arg</code> field can use one of the addressing modes in this list. Whether <code>000</code> refers to the A register or an immediate (K) depends on the &quot;instruction group&quot; (explained in following section).</p>
<p>There are 5 registers - A, B, C, X, and Y. A is the accumulator, and is used implicitly as an operand and destination in &quot;Group 0&quot; instructions. B, C, X, and Y are general purpose registers. X and Y also have the ability to be index registers when performing indexed memory addressing. Notably missing is a program counter register. All jumps use direct addressing, so there's no need to compute offsets, and function call return addresses can be stored as constants and loaded onto the stack manually.</p>
<h3 id="instruction-groups">Instruction groups</h3>
<p>There are four groups of instructions, indicated by the first two bits of the opcode.</p>
<p>Group 0: Two-operand arithmetic and logical operations. <code>arg==000</code> is a <code>NOP</code> instruction.</p>
<p>Group 1: Same as group 0, but the <code>arg</code> &quot;becomes the accumulator&quot;, and the operation is performed with an immediate (a constant stored in the next byte of the program). <code>arg==000</code> is the A register.</p>
<p>Group 2: A move instruction that moves the <code>arg</code> to a <code>dest</code>. <code>dest/arg==0</code> is the A register. If <code>dest==arg</code>, then <code>arg</code> is an immediate. This also supports moving an immediate to memory. Memory to memory moves are not supported by any implementation, but there's nothing instrinsic that would prevent them.</p>
<p>Group 3: Single argument arithmetic and logical operations. <code>arg==0</code> is the A register. Shoehorned into this group are the conditional and unconditional jump instructions. For unconditional jumps, <code>arg==0</code> is an immediate. Conditional jumps use the conditions in the bottom-right branching table. For example, to banch if the carry flag is set, use <code>bcs</code>, for branch if carry clear, use <code>bcc</code>. The same goes for the other flags <code>n,z,v</code>.</p>
<h1 id="minecraft-implementation-details">Minecraft implementation details</h1>
<p>The Minecraft implementation features:</p>
<ul>
<li>2Hz clock (5 redstone ticks per cycle)</li>
<li>4-stage pipeline</li>
<li>32 byte instruction cache</li>
<li>No data hazards</li>
<li>One cycle branch penalty</li>
<li>Executes one instruction byte per cycle</li>
<li>No program counter: A shift register is built into the instruction cache for advancing the IP</li>
<li>Harvard memory layout</li>
</ul>
<p>It also incorporates techniques to reduce the number of updates it causes during program execution, including:</p>
<ul>
<li>No clock: The CPU is perfectly synchronized and uses a &quot;Waterfall&quot; pipeline design</li>
<li>Minimal redstone to reduce game updates</li>
<li>Control lines are decoded directly instead of using a <a href="https://en.wikipedia.org/wiki/Programmable_logic_array">PLA</a></li>
<li>Pre-powered bussing lines</li>
</ul>
<h1 id="isa-rationale">ISA rationale</h1>
<blockquote>
<p>Why no SEC/CLC instructions like the 6502?</p>
</blockquote>
<p>The 6502 couldn't inc/dec the accumulator, and it didn't have add/sub without carry instructions. Having these instructions makes SEC/CLC unneeded.</p>
<blockquote>
<p>Why don't INC and DEC update carry flag?</p>
</blockquote>
<ul>
<li>Allows for carry flag to be preserved/used across iterations in loops</li>
<li>It's just as easy to detect roll-overs using N and Z flags</li>
<li>x86 does it the same way</li>
</ul>
<blockquote>
<p>Why no dedicated call/subroutine instructions?</p>
</blockquote>
<ul>
<li>Would likely violate 1 cycle per byte of instruction objective</li>
<li>The data path for these instructions is complicated, they require post/pre increment/decrement support on a stack pointer</li>
<li>Don't want to waste a full register on a stack pointer</li>
<li>User can decide what calling convention is most efficient</li>
<li>They can memory-map a stack, allowing for a call in 5 cycles and a return in 2 cycles</li>
</ul>
<blockquote>
<p>Why no fancy hardware, such as stack, barrel-shifter, multiplier, etc.?</p>
</blockquote>
<ul>
<li>Complex hardware optimizes for specific instead of general-purpose workloads</li>
<li>Increases the size of the CPU</li>
<li>Data paths become more complicated, likely not possible under the current speed constraints</li>
<li>Trivial to memory-map, which is a much more flexible approach</li>
</ul>
<blockquote>
<p>Why not use port-mapped I/O?</p>
</blockquote>
<ul>
<li>An ISA would likely force it to go through the accumulator instead of a register directly</li>
<li>Memory-mapped allows you to use different addressing modes</li>
<li>Like the point on fancier hardware, you're implementing something a program might not necessarily need, and might not be enough when you do</li>
</ul>
<blockquote>
<p>Why an accumulator architecture as opposed to a 3-op load-store?</p>
</blockquote>
<ul>
<li>Smaller program sizes due to denser instruction set</li>
<li>Simpler and speedier execution unit due to accumulator dataloop</li>
<li>Requires fewer components, lack of dual read registers, register decoders</li>
<li>A load-store variant would require a 16-bit ISA, increasing instruction cache pressure</li>
</ul>
<h1 id="memory-mapped-i-o">Memory-mapped I/O</h1>
<p>Memory-mapped devices are a great way to extend the functionality of the CPU. A device just has to define some interface of reading and writing to designated addresses. Here are some examples:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>8x16 TTY Screen
</span><span>[screen]: read char at cursor, write char to cursor
</span><span>[flags]: auto-increment, clear, character-set, etc.
</span><span>[cursor]: the index location of where to write to
</span><span>7-bit value for location of character, rrrcccc
</span><span>
</span><span>
</span><span>Ticker tape: for printing streams of decimal values
</span><span>[ticker]: write a value
</span><span>
</span><span>Keyboard:
</span><span>[keyboard]: works as a queue of characters
</span><span>[flags]: blocking/non-blocking read
</span><span>
</span><span>Multiplier 8x8=16
</span><span>[multiplicand]: Write multiplicand, read lower byte of product
</span><span>[multiplier]: Write multiplier, read upper byte of product
</span><span>
</span><span>Divider 8/8=(8,8) 
</span><span>[dividend]: Write dividend, read quotient
</span><span>[divisor]: Write divisor, read remainder
</span></code></pre>
<h1 id="assembler">Assembler</h1>
<p>An assembler was written in Rust.</p>
<h3 id="assembler-directives">Assembler directives</h3>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span style="color:#8fa1b3;">.</span><span style="color:#b48ead;">str    </span><span style="color:#a3be8c;">&quot;hello&quot;
</span><span style="color:#8fa1b3;">.strz   </span><span style="color:#a3be8c;">&quot;hello&quot;</span><span style="color:#65737e;"> ; null-terminated string
</span><span style="color:#8fa1b3;">.u8     </span><span style="color:#d08770;">5</span><span style="color:#65737e;">       ; define 8 bit integer
</span><span style="color:#8fa1b3;">.i16    </span><span style="color:#d08770;">32</span><span style="color:#65737e;">      ; define a signed 16-bit integer
</span><span style="color:#8fa1b3;">.u8     </span><span style="color:#d08770;">32</span><span>, </span><span style="color:#d08770;">26</span><span style="color:#65737e;">  ; define a list of unsigned 32-bit integers
</span></code></pre>
<h3 id="addressing-modes-1">Addressing modes</h3>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span style="color:#b48ead;">jmp </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x01</span><span style="color:#65737e;">   ; jump to the address stored at memory address 0x01
</span><span style="color:#b48ead;">jmp </span><span style="color:#d08770;">0x01</span><span style="color:#65737e;">    ; jump to the address 0x01
</span><span style="color:#b48ead;">jmp </span><span style="color:#8fa1b3;">label</span><span style="color:#65737e;">   ; jump to label or ram address
</span><span style="color:#b48ead;">jmp </span><span style="color:#8fa1b3;">B</span><span style="color:#65737e;">       ; jump to the value stored in register B
</span><span>
</span><span style="color:#b48ead;">add </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x05</span><span style="color:#65737e;">   ; add the value stored at memory address 0x05
</span><span style="color:#b48ead;">add </span><span style="color:#d08770;">0x05</span><span style="color:#65737e;">    ; add the value 0x05
</span><span>
</span><span style="color:#b48ead;">add </span><span style="color:#8fa1b3;">A</span><span>, </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#d08770;">1</span><span>]</span><span style="color:#65737e;">   ; add the value at memory[arr+1] to A
</span></code></pre>
<h1 id="example-programs">Example programs</h1>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span style="color:#65737e;">; Countdown program
</span><span style="color:#65737e;">; Print A..=0 to the TICKER device
</span><span style="color:#65737e;">; input a: the starting count
</span><span>
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">a</span><span>, </span><span style="color:#d08770;">10</span><span style="color:#65737e;">       ; move the decimal constant 10 to A
</span><span style="color:#b48ead;">loop</span><span style="color:#8fa1b3;">:   </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">TICKER</span><span>, </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">   ; write value in A to the ticker device
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">           ; decrement the value in A, updating the flags
</span><span style="color:#8fa1b3;">        bnc </span><span style="color:#b48ead;">loop</span><span style="color:#65737e;">        ; Branch to label &quot;loop&quot; while A is not negative
</span><span>
</span><span>
</span><span style="color:#65737e;">; Array sum
</span><span style="color:#65737e;">; input: x = length of the array minus 1
</span><span style="color:#65737e;">; result: sum in A
</span><span style="color:#8fa1b3;">arr:    .i8 </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">5</span><span>, -</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">4 
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">x</span><span>, </span><span style="color:#d08770;">5</span><span style="color:#65737e;">        ; store length of array minus 1 in X
</span><span style="color:#b48ead;">loop</span><span style="color:#8fa1b3;">:   </span><span style="color:#b48ead;">add </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#8fa1b3;">x</span><span>]</span><span style="color:#65737e;">      ; add the value at memory address [arr+x]
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">x</span><span style="color:#65737e;">           ; decrement X register
</span><span style="color:#8fa1b3;">        bnc </span><span style="color:#b48ead;">loop</span><span style="color:#65737e;">        ; while x &gt;= 0, goto loop
</span><span>
</span><span>
</span><span style="color:#65737e;">; Count set bits (popcnt) (5 bytes)
</span><span style="color:#65737e;">; input: B, C=0
</span><span style="color:#65737e;">; result: A
</span><span style="color:#b48ead;">loop</span><span style="color:#8fa1b3;">:   </span><span style="color:#b48ead;">adc </span><span style="color:#8fa1b3;">c</span><span style="color:#65737e;">       ; add the carry flag to the accumulator
</span><span style="color:#8fa1b3;">start:  </span><span style="color:#b48ead;">shr </span><span style="color:#8fa1b3;">b</span><span style="color:#65737e;">       ; shift LSB into carry flag
</span><span style="color:#8fa1b3;">        bne </span><span style="color:#b48ead;">loop</span><span style="color:#65737e;">    ; loop while b != 0
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">adc </span><span style="color:#8fa1b3;">c</span><span style="color:#65737e;">       ; dont forget final bit
</span><span>
</span><span>
</span><span style="color:#65737e;">; 8x8=8 multipy (7 bytes)
</span><span style="color:#65737e;">; multiplicant in b
</span><span style="color:#65737e;">; multiplier in c
</span><span style="color:#65737e;">; output in a
</span><span style="color:#8fa1b3;">do_add: </span><span style="color:#b48ead;">add </span><span style="color:#8fa1b3;">b
</span><span style="color:#b48ead;">loop</span><span style="color:#8fa1b3;">:   </span><span style="color:#b48ead;">shl </span><span style="color:#8fa1b3;">b
</span><span style="color:#8fa1b3;">start:  </span><span style="color:#b48ead;">shr </span><span style="color:#8fa1b3;">c</span><span style="color:#65737e;">       ; is multiplier odd?
</span><span style="color:#8fa1b3;">        bcs do_add</span><span style="color:#65737e;">  ; add the multiplicand
</span><span style="color:#8fa1b3;">        bne </span><span style="color:#b48ead;">loop</span><span style="color:#65737e;">    ; else loop while bits remaining in multiplier
</span><span>
</span><span>
</span><span style="color:#65737e;">; Collatz conjecture (14 bytes)
</span><span style="color:#65737e;">; starting value in A
</span><span style="color:#b48ead;">loop</span><span style="color:#8fa1b3;">:   </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">TICKER</span><span>, </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">   ; print value
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">shr </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">           ; divide by 2
</span><span style="color:#8fa1b3;">        bzs end</span><span style="color:#65737e;">         ; if we hit 0 we&#39;re done
</span><span style="color:#8fa1b3;">        bcc </span><span style="color:#b48ead;">loop</span><span style="color:#65737e;">        ; loop while even
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">rol </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">           ; restore true odd value
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">b</span><span>, </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">        ; compute a = 3a+1
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">shl </span><span style="color:#8fa1b3;">a
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">add </span><span style="color:#8fa1b3;">b
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">inc </span><span style="color:#8fa1b3;">a</span><span style="color:#65737e;">           ; a = 3a+1 at this point
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">jmp loop
</span><span style="color:#8fa1b3;">end:
</span><span>
</span><span>
</span><span style="color:#65737e;">; u8 insertion sort
</span><span style="color:#8fa1b3;">arr:    .u8 </span><span style="color:#d08770;">8</span><span>, </span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">36</span><span>, </span><span style="color:#d08770;">23</span><span>, </span><span style="color:#d08770;">48</span><span>, </span><span style="color:#d08770;">12</span><span>, </span><span style="color:#d08770;">42</span><span>, </span><span style="color:#d08770;">5
</span><span>
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">c</span><span>, </span><span style="color:#d08770;">9</span><span style="color:#65737e;">        ; length of array minus one
</span><span>
</span><span style="color:#8fa1b3;">outer:  </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">b</span><span>, </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#8fa1b3;">x</span><span>+</span><span style="color:#d08770;">1</span><span>]
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">y</span><span>, </span><span style="color:#8fa1b3;">x
</span><span>
</span><span style="color:#8fa1b3;">inner:  </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">a</span><span>, </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#8fa1b3;">y</span><span>]
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">cmp </span><span style="color:#8fa1b3;">b
</span><span style="color:#8fa1b3;">        bcc next
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#8fa1b3;">y</span><span>+</span><span style="color:#d08770;">1</span><span>], </span><span style="color:#8fa1b3;">a
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">y
</span><span style="color:#8fa1b3;">        bpl inner
</span><span>
</span><span style="color:#8fa1b3;">next:   </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">arr</span><span>[</span><span style="color:#8fa1b3;">y</span><span>+</span><span style="color:#d08770;">1</span><span>], </span><span style="color:#8fa1b3;">b
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">inc </span><span style="color:#8fa1b3;">x
</span><span style="color:#8fa1b3;">        </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">c
</span><span style="color:#8fa1b3;">        bne outer
</span></code></pre>
<h1 id="calling-convention">Calling convention</h1>
<p>The calling convention isn't strict and can be defined by the user. My preference is for the stack to grow downward with post-decrement for push. Here's an example implementation of that</p>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span>- </span><span style="color:#8fa1b3;">post</span><span>-</span><span style="color:#8fa1b3;">decrement stack for </span><span style="color:#b48ead;">push
</span><span>- </span><span style="color:#8fa1b3;">pre</span><span>-</span><span style="color:#8fa1b3;">increment for </span><span style="color:#b48ead;">pop
</span><span>- </span><span style="color:#8fa1b3;">PC pushed first</span><span>, </span><span style="color:#8fa1b3;">then function args </span><span style="color:#b48ead;">in </span><span style="color:#8fa1b3;">reverse order
</span><span>
</span><span>
</span><span style="color:#65737e;">; def my_func(a, b):
</span><span style="color:#65737e;">;     return a - b
</span><span>
</span><span style="color:#8fa1b3;">my_func:
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">mov </span><span style="color:#8fa1b3;">a</span><span>, [</span><span style="color:#8fa1b3;">stack</span><span>+</span><span style="color:#d08770;">1</span><span>]</span><span style="color:#65737e;">    ; access 1st arg
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">sub </span><span>[</span><span style="color:#8fa1b3;">stack</span><span>+</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#65737e;">       ; access 2nd arg
</span><span>
</span><span style="color:#65737e;">    ; despite being accumulator, we can add imm constants
</span><span style="color:#65737e;">    ; to registers, handy for collapsing stack frame
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">add </span><span style="color:#8fa1b3;">stack</span><span>, </span><span style="color:#d08770;">3</span><span style="color:#65737e;">        ; num args + 1 for pc
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">jmp </span><span>[</span><span style="color:#8fa1b3;">stack</span><span>]</span><span style="color:#65737e;">         ; return
</span><span>
</span><span>
</span><span style="color:#65737e;">; my_func(3, 5)
</span><span style="color:#65737e;">    ; push the program counter
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">mov </span><span>[</span><span style="color:#8fa1b3;">stack</span><span>], </span><span style="color:#8fa1b3;">PC
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">stack
</span><span>
</span><span style="color:#8fa1b3;">    # </span><span style="color:#b48ead;">push </span><span style="color:#8fa1b3;">args </span><span style="color:#b48ead;">in </span><span style="color:#8fa1b3;">reverse order
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">mov </span><span>[</span><span style="color:#8fa1b3;">stack</span><span>], </span><span style="color:#d08770;">5</span><span style="color:#65737e;">      ; can push imm/reg directly
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">stack
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">mov </span><span>[</span><span style="color:#8fa1b3;">stack</span><span>], </span><span style="color:#d08770;">3
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">dec </span><span style="color:#8fa1b3;">stack
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">jmp </span><span style="color:#8fa1b3;">my_func</span><span style="color:#65737e;">         ; call
</span><span>
</span></code></pre>
<h1 id="future-plans">Future plans</h1>
<ul>
<li>Implement a <a href="https://en.wikipedia.org/wiki/Superoptimization">super-optimizer</a></li>
<li>Polish assembler and emulator</li>
<li>4-tick implementation :O</li>
</ul>

        </div>
    </article>

    <script src="https://utteranc.es/client.js"
    repo="benburk/benburk.github.io"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
    </script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
        MathJax = {
            tex: {
            displayMath: [['$$', '$$'], ["\\[", "\\]"]],
            inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</main>

        </main>

        <footer>
            <div class="footer-content">
            <div class="footer-content-left">
                
            </div>
            <div class="footer-content-right">
                
                
                <a href="https:&#x2F;&#x2F;github.com&#x2F;benburk">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="20">
                        <path fill="#1e1e1e" d="M512 0C229.25 0 0 229.25 0 512c0 226.25 146.688 418.125 350.156 485.812 25.594 4.688 34.938-11.125 34.938-24.625 0-12.188-.469-52.562-.719-95.312C242 908.812 211.906 817.5 211.906 817.5c-23.312-59.125-56.844-74.875-56.844-74.875-46.531-31.75 3.53-31.125 3.53-31.125 51.406 3.562 78.47 52.75 78.47 52.75 45.688 78.25 119.875 55.625 149 42.5 4.654-33 17.904-55.625 32.5-68.375-113.656-12.937-233.218-56.875-233.218-253.063 0-55.938 19.969-101.562 52.656-137.406-5.219-13-22.844-65.094 5.062-135.562 0 0 42.938-13.75 140.812 52.5 40.812-11.406 84.594-17.031 128.125-17.219 43.5.188 87.312 5.875 128.188 17.281 97.688-66.312 140.688-52.5 140.688-52.5 28 70.531 10.375 122.562 5.125 135.5 32.812 35.844 52.625 81.469 52.625 137.406 0 196.688-119.75 240-233.812 252.688 18.438 15.875 34.75 47 34.75 94.75 0 68.438-.688 123.625-.688 140.5 0 13.625 9.312 29.562 35.25 24.562C877.438 930 1024 738.125 1024 512 1024 229.25 794.75 0 512 0z"/>
                    </svg>
                </a>
                
            </div>
            </div>
        </footer>
    </body>
</html>
